/*
 * generated by Xtext 2.21.0
 */
package dk.sdu.mdsd.mathcompiler.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import dk.sdu.mdsd.mathcompiler.compiler.MathExp
import javax.swing.JOptionPane
import java.util.HashMap
import dk.sdu.mdsd.mathcompiler.compiler.Expression
import java.util.Map
import dk.sdu.mdsd.mathcompiler.compiler.Plus
import dk.sdu.mdsd.mathcompiler.compiler.Minus
import dk.sdu.mdsd.mathcompiler.compiler.Mult
import dk.sdu.mdsd.mathcompiler.compiler.Div
import dk.sdu.mdsd.mathcompiler.compiler.Num
import dk.sdu.mdsd.mathcompiler.compiler.Paren
import java.util.UUID
import java.util.List
import java.util.ArrayList
import dk.sdu.mdsd.mathcompiler.compiler.External

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */


class CompilerGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val content = resource.allContents.toList
		var mathExps = content.filter(MathExp).toList
		var externals = content.filter(External).toList
		fsa.generateFile("output.java", fileDescriptor(mathExps, externals))
	}
	
	def String fileDescriptor(List<MathExp> mathExps, List<External> externals) {
		// For all intents and purposes this acts as "good enough" as an example however the varible assignment in the interafe would need to
		// be improved further if this were to be taken anywhere
		var char variable = 'a';
		return '''
		import java.util.*;
		public class MathComputation {
			// BEGIN: required for external functions
			public static interface Externals {
				«FOR external : externals»
				public int «external.ext»(«FOR parameter : external.parameters SEPARATOR ', '»int «variable++»«ENDFOR»);
				«ENDFOR»
			}
			private Externals externals;
			public MathComputation(Externals _externals) {
			    externals = _externals;
			}
			// END: required for external functions
			
			public void calculate() {
				«FOR math : mathExps»
				System.out.println("«math.label» = " + («math.compileMath»));
				«ENDFOR»
			    // BEGIN: external functions only
				«FOR external : externals»
				System.out.println("«external.label» = " + (externals.«external.ext»(«FOR parameter : external.parameters SEPARATOR ', '»«parameter»«ENDFOR»)));
				«ENDFOR»
			    // END: external functions only
				
			}
		}
		'''
	}

	def CharSequence compileMath(MathExp math) {
		'''«math.exp.compileExp»'''
	}
	def dispatch CharSequence compileExp(Plus plus) {
		'''«plus.left.compileExp» + «plus.right.compileExp»'''
	}
	def dispatch CharSequence compileExp(Minus minus) {
		'''«minus.left.compileExp» - «minus.right.compileExp»'''
	}
	def dispatch CharSequence compileExp(Mult mult) {
		'''«mult.left.compileExp» * «mult.right.compileExp»'''
	}
	def dispatch CharSequence compileExp(Div div) {
		'''«div.left.compileExp» / «div.right.compileExp»'''
	}
	def dispatch CharSequence compileExp(Paren paren) {
		'''(«paren.exp.compileExp»)'''	
	}
	def dispatch CharSequence compileExp(Num num) {
		Integer.toString(num.value)
	}
}
